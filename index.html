<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>眨眼之间 · 星空轨道</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- 进入时间 -->
  <div id="enter-btn">进入时间</div>

  <!-- 星空 + 轨道 -->
  <canvas id="space"></canvas>

  <!-- 回到初始视角 -->
  <button id="resetView" class="hidden">回到初始视角</button>

  <!-- 背景音乐：请在仓库根目录上传 bgm.mp3 -->
  <audio id="bgm" src="bgm.mp3" loop></audio>

  <script>
    const canvas = document.getElementById("space");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    // 相机视角 & 缩放
    let yaw = 0, pitch = 0;
    let targetYaw = 0, targetPitch = 0;
    let zoom = 1, targetZoom = 1;

    // 时间：epoch 越大，轨道系统“悄悄偏移”越多
    const EPOCH_KEY = "orbit_epoch_v2";
    let epoch = parseInt(localStorage.getItem(EPOCH_KEY) || "0", 10);
    let lastActivity = Date.now();
    function saveEpoch() {
      localStorage.setItem(EPOCH_KEY, String(epoch));
    }
    function markActivity() {
      lastActivity = Date.now();
    }

    // ---------- 背景星空 ----------
    const STAR_COUNT = 2200;
    const stars = [];

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        // 分两层：近层、远层，增强空间感
        const layer = Math.random() < 0.55 ? 0 : 1; // 0: 近, 1: 远
        const baseR = layer === 0 ? 0.7 : 1.2;
        const jitter = layer === 0 ? 0.4 : 0.6;
        const r = baseR + Math.random() * jitter;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        stars.push({
          x,
          y,
          z,
          layer,
          b: 0.25 + Math.random() * 0.7
        });
      }
    }
    initStars();

    // ---------- 轨道系统 ----------
    const DEG = Math.PI / 180;

    const orbits = [
      {
        radius: 0.32,
        width: 0.7,
        color: "rgba(255,255,255,0.16)",
        tiltOffset: -8 * DEG,
        twistOffset: 10 * DEG
      },
      {
        radius: 0.50,
        width: 0.7,
        color: "rgba(255,255,255,0.13)",
        tiltOffset: -3 * DEG,
        twistOffset: -5 * DEG
      },
      {
        radius: 0.72,
        width: 0.7,
        color: "rgba(255,255,255,0.11)",
        tiltOffset: 4 * DEG,
        twistOffset: 18 * DEG
      },
      {
        radius: 0.95,
        width: 0.7,
        color: "rgba(255,255,255,0.10)",
        tiltOffset: 10 * DEG,
        twistOffset: -15 * DEG
      }
    ];

    const planets = [
      { orbitIndex: 0, basePhase: 0.0,  size: 0.010, speed: 0.22, color: "#f5f5ff" },
      { orbitIndex: 1, basePhase: 2.1,  size: 0.012, speed: 0.18, color: "#b3d9ff" },
      { orbitIndex: 2, basePhase: 3.8,  size: 0.014, speed: 0.13, color: "#ffd9a0" },
      { orbitIndex: 3, basePhase: 5.2,  size: 0.016, speed: 0.09, color: "#ffe8ff" }
    ];

    // ---------- 投影 ----------
    function projectPoint(px, py, pz) {
      // 相机旋转（yaw/pitch）
      const cosY = Math.cos(yaw);
      const sinY = Math.sin(yaw);
      const cosP = Math.cos(pitch);
      const sinP = Math.sin(pitch);

      let x = px * cosY - pz * sinY;
      let z = px * sinY + pz * cosY;

      let y = py * cosP - z * sinP;
      z = py * sinP + z * cosP;

      // zoom 现在影响“视距”和视角，不只是放大
      const baseDist = Math.max(1.2, 2.6 - (zoom - 1) * 1.3);
      const zoomFactor = 1 + (zoom - 1) * 0.8;
      const f = 0.9 * zoomFactor / (z + baseDist);

      const w = canvas.width;
      const h = canvas.height;
      const s = Math.min(w, h);

      return {
        sx: x * f * s + w / 2,
        sy: y * f * s + h / 2,
        depth: z,
        scale: f
      };
    }

    // ---------- 时间驱动参数（极慢变化） ----------
    function getTimeParams(time) {
      // 一个完整循环需要 240 次 epoch，非常慢
      const MAX_EPOCH = 240;
      const p = (epoch % MAX_EPOCH) / MAX_EPOCH; // 0~1

      // 轨道平面整体倾角：-8° ~ +8°
      const tiltAmp = 8 * DEG;
      const tiltGlobal = (p * 2 - 1) * tiltAmp;

      // 椭圆化程度：ecc = 1 ~ 1.08
      const ecc = 1 + 0.08 * Math.sin(p * Math.PI * 2);

      // 全局扭转：-10° ~ +10°
      const twAmp = 10 * DEG;
      const twistGlobal = (p * 2 - 1) * twAmp;

      // 行星整体相位偏移：最多偏移一小截
      const phaseOffset = p * Math.PI * 2 * 0.15;

      // 行星自身运动（为了不太死），速度比之前慢很多
      const t = time * 0.000015;

      return { tiltGlobal, ecc, twistGlobal, phaseOffset, t };
    }

    // ---------- 鼠标 / 触摸交互 ----------
    let dragging = false;
    let lastX = 0, lastY = 0;

    canvas.addEventListener("mousedown", (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      markActivity();
    });

    window.addEventListener("mouseup", () => {
      dragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      targetPitch = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, targetPitch));
      markActivity();
    });

    // 触控
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      dragging = true;
      lastX = t.clientX;
      lastY = t.clientY;
      markActivity();
    });

    canvas.addEventListener("touchmove", (e) => {
      if (!dragging || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - lastX;
      const dy = t.clientY - lastY;
      lastX = t.clientX;
      lastY = t.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      targetPitch = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, targetPitch));
      markActivity();
    });

    canvas.addEventListener("touchend", () => {
      dragging = false;
    });

    // 滚轮缩放：范围更大一点，空间感更明显
    window.addEventListener(
      "wheel",
      (e) => {
        const delta = e.deltaY > 0 ? -0.08 : 0.08;
        targetZoom = Math.min(2.1, Math.max(0.7, targetZoom + delta));
        markActivity();
      },
      { passive: true }
    );

    // 长时间停留无操作 → epoch + 1（40 秒才算一次）
    setInterval(() => {
      const now = Date.now();
      if (now - lastActivity > 40000) {
        epoch++;
        saveEpoch();
        lastActivity = now;
      }
    }, 10000);

    // 标签页切走再回来 → epoch + 1
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        epoch++;
        saveEpoch();
      }
    });

    // ---------- 轨道坐标 ----------
    function orbitPoint(orbit, angle, ecc, tiltGlobal, twistGlobal) {
      const radius = orbit.radius;
      const localTilt = tiltGlobal + (orbit.tiltOffset || 0);
      const localTwist = twistGlobal + (orbit.twistOffset || 0);

      const x0 = radius * Math.cos(angle);
      const y0 = radius * ecc * Math.sin(angle);

      // 本地扭转（绕 Z）
      const cosTw = Math.cos(localTwist);
      const sinTw = Math.sin(localTwist);
      let x1 = x0 * cosTw - y0 * sinTw;
      let y1 = x0 * sinTw + y0 * cosTw;
      let z1 = 0;

      // 本地倾斜（绕 X）
      const cosT = Math.cos(localTilt);
      const sinT = Math.sin(localTilt);
      let y2 = y1 * cosT - z1 * sinT;
      let z2 = y1 * sinT + z1 * cosT;

      return { x: x1, y: y2, z: z2 };
    }

    // ---------- 主绘制 ----------
    function draw(time) {
      requestAnimationFrame(draw);

      // 平滑相机
      const lerp = 0.08;
      yaw += (targetYaw - yaw) * lerp;
      pitch += (targetPitch - pitch) * lerp;
      zoom += (targetZoom - zoom) * lerp;

      const { tiltGlobal, ecc, twistGlobal, phaseOffset, t } = getTimeParams(time);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#02040b";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ----- 背景星空 -----
      for (const s of stars) {
        const p = projectPoint(s.x, s.y, s.z);
        if (p.depth > 2.5) continue;

        // 近层对 zoom 更敏感，远层几乎不变，增强“走进空间”的感觉
        const layerFactor = s.layer === 0 ? zoom * 1.2 : 0.6 + zoom * 0.2;
        const flicker = 0.8 + Math.random() * 0.4;
        const alpha = Math.min(1, s.b * p.scale * 1.7 * layerFactor * flicker);
        if (alpha <= 0.015) continue;

        ctx.fillStyle = `rgba(240,245,255,${alpha})`;
        ctx.fillRect(p.sx, p.sy, 1.0, 1.0);
      }

      // ----- 轨道线 -----
      for (const orbit of orbits) {
        ctx.beginPath();
        const steps = 140;
        let first = true;
        for (let i = 0; i <= steps; i++) {
          const a = (i / steps) * Math.PI * 2;
          const pos = orbitPoint(orbit, a, ecc, tiltGlobal, twistGlobal);
          const p = projectPoint(pos.x, pos.y, pos.z);
          if (p.depth > 2.3) continue;
          if (first) {
            ctx.moveTo(p.sx, p.sy);
            first = false;
          } else {
            ctx.lineTo(p.sx, p.sy);
          }
        }
        ctx.strokeStyle = orbit.color;
        ctx.lineWidth = orbit.width;
        ctx.stroke();
      }

      // ----- 中央恒星 -----
      const core = projectPoint(0, 0, 0);
      const coreRadius = 6 * zoom;
      const grad = ctx.createRadialGradient(
        core.sx, core.sy, 0,
        core.sx, core.sy, coreRadius * 2.1
      );
      grad.addColorStop(0, "rgba(255,255,255,0.7)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(core.sx, core.sy, coreRadius * 2.1, 0, Math.PI * 2);
      ctx.fill();

      // ----- 行星 -----
      for (const pl of planets) {
        const orbit = orbits[pl.orbitIndex];
        const angle = pl.basePhase + phaseOffset + t * pl.speed * Math.PI * 2;
        const pos = orbitPoint(orbit, angle, ecc, tiltGlobal, twistGlobal);
        const p = projectPoint(pos.x, pos.y, pos.z);
        if (p.depth > 2.5) continue;

        const screenSize = pl.size * canvas.height * zoom / (p.depth + 2.4);
        const r = Math.max(1.6, screenSize);

        ctx.beginPath();
        ctx.fillStyle = pl.color;
        ctx.shadowColor = pl.color;
        ctx.shadowBlur = 10;
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // ---------- 按钮 & BGM ----------
    const enterBtn = document.getElementById("enter-btn");
    const resetBtn = document.getElementById("resetView");
    const bgm = document.getElementById("bgm");

    enterBtn.addEventListener("click", () => {
      enterBtn.classList.add("hidden");
      resetBtn.classList.remove("hidden");

      if (bgm) {
        bgm.volume = 0.5;
        bgm.play().catch(() => {});
      }
      markActivity();
    });

    resetBtn.addEventListener("click", () => {
      targetYaw = 0;
      targetPitch = 0;
      targetZoom = 1;
      markActivity();
    });

    markActivity();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
