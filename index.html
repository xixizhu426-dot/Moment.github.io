<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>眨眼之间 · 星空轨道</title>

  <!-- 所有样式直接写在这里，避免外链 CSS 出问题 -->
  <style>
    /* ============ 页面基础设置：全屏 + 无滚动 ============ */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000; /* 首屏纯黑，点击后由 canvas 接管画面 */
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      user-select: none;
    }

    /* ============ 全屏 Canvas（默认透明，点击后淡入） ============ */
    #space {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      opacity: 0;
      transition: opacity 1.8s ease;
      z-index: 1;
    }

    /* body.started 说明用户已经点击了“进入时间” */
    body.started #space {
      opacity: 1;
    }

    /* ============ 进入时间按钮 ============ */
    #enter-btn {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.8rem;
      color: rgba(255, 255, 255, 0.9);
      border: 1.4px solid rgba(255, 255, 255, 0.5);
      padding: 18px 42px;
      cursor: pointer;
      letter-spacing: 0.12em;
      backdrop-filter: blur(14px);
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      transition: opacity 0.8s ease, transform 0.8s ease;
      z-index: 20;
    }

    #enter-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translate(-50%, -50%) scale(1.05);
    }

    /* ============ 回到初始视角按钮 ============ */
    #resetView {
      position: fixed;
      top: 32px;
      right: 32px;
      padding: 10px 22px;
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.9);
      border: 1.2px solid rgba(255, 255, 255, 0.28);
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 0.1em;
      backdrop-filter: blur(12px);
      z-index: 15;
      transition: opacity 0.6s ease, background 0.2s ease;
    }

    #resetView:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    /* ============ 底部提示文案 ============ */
    #hint {
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.82);
      letter-spacing: 0.12em;
      padding: 6px 16px;
      background: rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(14px);
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      transition: opacity 0.6s ease;
      z-index: 18;
    }

    /* ============ 通用隐藏状态 ============ */
    .hidden {
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* 取消 Mobile 点击高亮 */
    button, div, canvas {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <!-- 首屏：进入时间 -->
  <div id="enter-btn">进入时间</div>

  <!-- 星空 + 轨道画布 -->
  <canvas id="space"></canvas>

  <!-- 回到初始视角按钮（初始隐藏） -->
  <button id="resetView" class="hidden">回到初始视角</button>

  <!-- 底部提示文案（初始隐藏） -->
  <div id="hint" class="hidden">改变视角，看看有什么不同</div>

  <!-- 背景音乐：如果你在仓库根目录上传 bgm.mp3，这里会自动播放 -->
  <audio id="bgm" src="bgm.mp3" loop></audio>

  <!-- 所有 JS 也直接写在这里 -->
  <script>
    const canvas = document.getElementById("space");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    // 相机视角 & 缩放
    let yaw = 0, pitch = 0;
    let targetYaw = 0, targetPitch = 0;
    let cameraDist = 2.6;
    let targetCameraDist = 2.6;

    // 时间 epoch：只在“离开页面再回来”时 +1
    const EPOCH_KEY = "orbit_epoch_v4";
    let epoch = parseInt(localStorage.getItem(EPOCH_KEY) || "0", 10);
    function saveEpoch() {
      localStorage.setItem(EPOCH_KEY, String(epoch));
    }

    // ========== 背景星空 ==========
    const STAR_COUNT = 2200;
    const stars = [];

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        const layer = Math.random() < 0.55 ? 0 : 1; // 0: 近层, 1: 远层
        const baseR = layer === 0 ? 0.7 : 1.2;
        const jitter = layer === 0 ? 0.5 : 0.8;
        const r = baseR + Math.random() * jitter;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        stars.push({
          x,
          y,
          z,
          layer,
          b: 0.3 + Math.random() * 0.7
        });
      }
    }
    initStars();

    // ========== 轨道系统 ==========
    const DEG = Math.PI / 180;

    const orbits = [
      { radius: 0.32, width: 0.7, color: "rgba(255,255,255,0.16)", tiltOffset: -8 * DEG, twistOffset:  10 * DEG },
      { radius: 0.50, width: 0.7, color: "rgba(255,255,255,0.13)", tiltOffset: -4 * DEG, twistOffset:  -6 * DEG },
      { radius: 0.72, width: 0.7, color: "rgba(255,255,255,0.11)", tiltOffset:  3 * DEG, twistOffset:  18 * DEG },
      { radius: 0.95, width: 0.7, color: "rgba(255,255,255,0.10)", tiltOffset: 10 * DEG, twistOffset: -15 * DEG }
    ];

    const planets = [
      { orbitIndex: 0, basePhase: 0.0, size: 0.010, color: "#f5f5ff" },
      { orbitIndex: 1, basePhase: 2.1, size: 0.012, color: "#b3d9ff" },
      { orbitIndex: 2, basePhase: 3.8, size: 0.014, color: "#ffd9a0" },
      { orbitIndex: 3, basePhase: 5.2, size: 0.016, color: "#ffe8ff" }
    ];

    // ========== 投影：考虑相机旋转 + 前后距离 ==========
    function projectPoint(px, py, pz) {
      let x = px;
      let y = py;
      let z = pz;

      const cosY = Math.cos(yaw);
      const sinY = Math.sin(yaw);
      const cosP = Math.cos(pitch);
      const sinP = Math.sin(pitch);

      // 绕 Y
      let x1 = x * cosY - z * sinY;
      let z1 = x * sinY + z * cosY;
      // 绕 X
      let y1 = y * cosP - z1 * sinP;
      z1 = y * sinP + z1 * cosP;

      const dist = cameraDist + 1.2;
      const f = 1.0 / (z1 + dist);

      const w = canvas.width;
      const h = canvas.height;
      const s = Math.min(w, h);

      return {
        sx: x1 * f * s + w / 2,
        sy: y1 * f * s + h / 2,
        depth: z1,
        scale: f
      };
    }

    // ========== epoch → 非常缓慢的参数变化 ==========
    function getTimeParams() {
      const MAX_EPOCH = 240; // 240 次“离开再回来”绕一圈
      const p = (epoch % MAX_EPOCH) / MAX_EPOCH; // 0~1

      // 轨道整体倾角：-4° ~ +4°
      const tiltAmp = 4 * DEG;
      const tiltGlobal = (p * 2 - 1) * tiltAmp;

      // 椭圆化程度：ecc = 1 ~ 1.04
      const ecc = 1 + 0.04 * Math.sin(p * Math.PI * 2);

      // 全局扭转：-5° ~ +5°
      const twAmp = 5 * DEG;
      const twistGlobal = (p * 2 - 1) * twAmp;

      // 行星整体相位偏移：轻微
      const phaseOffset = p * Math.PI * 2 * 0.08;

      return { tiltGlobal, ecc, twistGlobal, phaseOffset };
    }

    function orbitPoint(orbit, angle, ecc, tiltGlobal, twistGlobal) {
      const radius = orbit.radius;
      const localTilt = tiltGlobal + (orbit.tiltOffset || 0);
      const localTwist = twistGlobal + (orbit.twistOffset || 0);

      const x0 = radius * Math.cos(angle);
      const y0 = radius * ecc * Math.sin(angle);

      // 扭转（绕 Z）
      const cosTw = Math.cos(localTwist);
      const sinTw = Math.sin(localTwist);
      let x1 = x0 * cosTw - y0 * sinTw;
      let y1 = x0 * sinTw + y0 * cosTw;
      let z1 = 0;

      // 倾角（绕 X）
      const cosT = Math.cos(localTilt);
      const sinT = Math.sin(localTilt);
      let y2 = y1 * cosT - z1 * sinT;
      let z2 = y1 * sinT + z1 * cosT;

      // 略微加厚增强 3D 感
      z2 *= 1.7;

      return { x: x1, y: y2, z: z2 };
    }

    // ========== 交互：旋转、缩放 ==========
    let dragging = false;
    let lastX = 0, lastY = 0;
    let hasInteracted = false;
    const hint = document.getElementById("hint");

    function userInteracted() {
      if (!hasInteracted) {
        hasInteracted = true;
        if (hint) hint.classList.add("hidden");
      }
    }

    canvas.addEventListener("mousedown", (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      userInteracted();
    });

    window.addEventListener("mouseup", () => {
      dragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      const limit = Math.PI / 2 - 0.25;
      targetPitch = Math.max(-limit, Math.min(limit, targetPitch));
    });

    // 触摸旋转
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      dragging = true;
      lastX = t.clientX;
      lastY = t.clientY;
      userInteracted();
    });

    canvas.addEventListener("touchmove", (e) => {
      if (!dragging || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - lastX;
      const dy = t.clientY - lastY;
      lastX = t.clientX;
      lastY = t.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      const limit = Math.PI / 2 - 0.25;
      targetPitch = Math.max(-limit, Math.min(limit, targetPitch));
    });

    canvas.addEventListener("touchend", () => {
      dragging = false;
    });

    // 滚轮缩放（相机远近）
    window.addEventListener("wheel", (e) => {
      const delta = e.deltaY > 0 ? 0.18 : -0.18;
      targetCameraDist = Math.min(4.2, Math.max(1.6, targetCameraDist + delta));
      userInteracted();
    }, { passive: true });

    // 标签页切走再回来 → epoch + 1
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        epoch++;
        saveEpoch();
      }
    });

    // ========== 主绘制循环 ==========
    function draw() {
      requestAnimationFrame(draw);

      const lerp = 0.08;
      yaw += (targetYaw - yaw) * lerp;
      pitch += (targetPitch - pitch) * lerp;
      cameraDist += (targetCameraDist - cameraDist) * lerp;

      const { tiltGlobal, ecc, twistGlobal, phaseOffset } = getTimeParams();

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#02040b";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 背景星空
      for (const s of stars) {
        const p = projectPoint(s.x, s.y, s.z);
        if (p.depth > 4) continue;
        const layerFactor = s.layer === 0 ? (3.2 - cameraDist) * 0.7 : 0.5;
        const alphaBase = s.b * p.scale * 1.6;
        const alpha = Math.min(1, alphaBase * (0.6 + layerFactor));
        if (alpha <= 0.015) continue;
        ctx.fillStyle = `rgba(235,240,255,${alpha})`;
        ctx.fillRect(p.sx, p.sy, 1.0, 1.0);
      }

      // 轨道线
      for (const orbit of orbits) {
        ctx.beginPath();
        const steps = 140;
        let first = true;
        for (let i = 0; i <= steps; i++) {
          const a = (i / steps) * Math.PI * 2;
          const pos = orbitPoint(orbit, a, ecc, tiltGlobal, twistGlobal);
          const p = projectPoint(pos.x, pos.y, pos.z);
          if (p.depth > 3) continue;
          if (first) {
            ctx.moveTo(p.sx, p.sy);
            first = false;
          } else {
            ctx.lineTo(p.sx, p.sy);
          }
        }
        ctx.strokeStyle = orbit.color;
        ctx.lineWidth = orbit.width;
        ctx.stroke();
      }

      // 中央恒星
      const core = projectPoint(0, 0, 0);
      const coreRadius = 6 / cameraDist;
      const grad = ctx.createRadialGradient(
        core.sx, core.sy, 0,
        core.sx, core.sy, coreRadius * 3
      );
      grad.addColorStop(0, "rgba(255,255,255,0.7)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(core.sx, core.sy, coreRadius * 3, 0, Math.PI * 2);
      ctx.fill();

      // 行星（在每个 epoch 内静止）
      for (const pl of planets) {
        const orbit = orbits[pl.orbitIndex];
        const angle = pl.basePhase + phaseOffset;
        const pos = orbitPoint(orbit, angle, ecc, tiltGlobal, twistGlobal);
        const p = projectPoint(pos.x, pos.y, pos.z);
        if (p.depth > 3.2) continue;
        const screenSize = pl.size * canvas.height / (p.depth + cameraDist + 2.4);
        const r = Math.max(1.5, screenSize);
        ctx.beginPath();
        ctx.fillStyle = pl.color;
        ctx.shadowColor = pl.color;
        ctx.shadowBlur = 10;
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // ========== 按钮 & BGM & 首屏动画 ==========
    const enterBtn = document.getElementById("enter-btn");
    const resetBtn = document.getElementById("resetView");
    const bgm = document.getElementById("bgm");

    enterBtn.addEventListener("click", () => {
      // 给 body 加上 started，用于控制 canvas 淡入
      document.body.classList.add("started");

      // 按钮淡出
      enterBtn.classList.add("hidden");

      // 显示“回到初始视角”和提示文案
      resetBtn.classList.remove("hidden");
      if (hint) hint.classList.remove("hidden");

      // 放音乐（如果有）
      if (bgm) {
        bgm.volume = 0.5;
        bgm.play().catch(() => {});
      }
    });

    resetBtn.addEventListener("click", () => {
      targetYaw = 0;
      targetPitch = 0;
      targetCameraDist = 2.6;
    });

    requestAnimationFrame(draw);
  </script>
</body>
</html>
