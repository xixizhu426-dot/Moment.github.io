<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>眨眼之间 · 星空轨道</title>

  <style>
    /* ============ 页面基础设置：全屏 + 无滚动 ============ */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      user-select: none;
    }

    /* ============ 主 Canvas ============ */
    #space {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      opacity: 0;
      transition: opacity 1.8s ease;
      z-index: 1;
    }

    /* ============ 行星轨迹覆盖层 ============ */
    #trail {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 5;
      pointer-events: none;
    }

    body.started #space {
      opacity: 1;
    }

    /* ============ 进入时间按钮 ============ */
    #enter-btn {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.8rem;
      color: rgba(255, 255, 255, 0.9);
      border: 1.4px solid rgba(255, 255, 255, 0.5);
      padding: 18px 42px;
      cursor: pointer;
      letter-spacing: 0.12em;
      backdrop-filter: blur(14px);
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      transition: opacity 0.8s ease, transform 0.8s ease;
      z-index: 20;
    }

    #enter-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translate(-50%, -50%) scale(1.05);
    }

    /* ============ 回到初始视角按钮 ============ */
    #resetView {
      position: fixed;
      top: 32px;
      right: 32px;
      padding: 10px 22px;
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.9);
      border: 1.2px solid rgba(255, 255, 255, 0.28);
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 0.1em;
      backdrop-filter: blur(12px);
      z-index: 15;
      transition: opacity 0.6s ease, background 0.2s ease;
    }

    #resetView:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    /* ============ 底部提示文案 ============ */
    #hint {
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.82);
      letter-spacing: 0.12em;
      padding: 6px 16px;
      background: rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(14px);
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      transition: opacity 0.6s ease;
      z-index: 18;
    }

    /* ============ 底部 BEFORE / NOW 对比条 ============ */
    #compare-panel {
      position: fixed;
      bottom: 26px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 25;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease;
    }

    #compare-panel.active {
      opacity: 1;
      pointer-events: none; /* 让事件透过去，不打断交互 */
    }

    .compare-inner {
      pointer-events: auto; /* 内部按钮可点击 */
      max-width: min(720px, 92vw);
      width: 100%;
      background: rgba(10, 12, 24, 0.95);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      padding: 10px 14px 10px;
      box-shadow: 0 16px 38px rgba(0, 0, 0, 0.6);
      color: #fff;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .compare-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .compare-title {
      font-size: 0.78rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      opacity: 0.85;
      white-space: nowrap;
    }

    .compare-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      align-items: center;
    }

    .compare-item {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 14px;
      padding: 6px 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .compare-label {
      font-size: 0.72rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.75;
    }

    .compare-item img {
      width: 100%;
      border-radius: 10px;
      display: block;
      background: #000;
    }

    #close-compare {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.06);
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    #close-compare:hover {
      background: rgba(255, 255, 255, 0.18);
    }

    /* ============ 通用隐藏状态 ============ */
    .hidden {
      opacity: 0 !important;
      pointer-events: none !important;
    }

    button, div, canvas {
      -webkit-tap-highlight-color: transparent;
    }

    @media (max-width: 640px) {
      .compare-inner {
        padding: 8px 10px 8px;
      }
      .compare-grid {
        grid-template-columns: 1fr 1fr;
      }
      .compare-title {
        letter-spacing: 0.18em;
      }
    }
  </style>
</head>
<body>
  <!-- 首屏：进入时间 -->
  <div id="enter-btn">进入时间</div>

  <!-- 星空 + 轨道画布 -->
  <canvas id="space"></canvas>

  <!-- 行星轨迹画布 -->
  <canvas id="trail"></canvas>

  <!-- 回到初始视角按钮（初始隐藏） -->
  <button id="resetView" class="hidden">回到初始视角</button>

  <!-- 底部提示文案（初始隐藏） -->
  <div id="hint" class="hidden">改变视角，看看有什么不同</div>

  <!-- 底部 BEFORE / NOW 对比条 -->
  <div id="compare-panel">
    <div class="compare-inner">
      <div class="compare-head">
        <div class="compare-title">VIEW · BEFORE / NOW</div>
        <button id="close-compare">×</button>
      </div>
      <div class="compare-grid">
        <div class="compare-item">
          <div class="compare-label">BEFORE</div>
          <img id="img-before" alt="Before view" />
        </div>
        <div class="compare-item">
          <div class="compare-label">NOW</div>
          <img id="img-now" alt="Now view" />
        </div>
      </div>
    </div>
  </div>

  <!-- 背景音乐 -->
  <audio id="bgm" src="bgm.mp3" loop></audio>

  <script>
    const canvas = document.getElementById("space");
    const ctx = canvas.getContext("2d");

    const trailCanvas = document.getElementById("trail");
    const trailCtx = trailCanvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      trailCanvas.width = window.innerWidth;
      trailCanvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    // 相机视角 & 缩放（初始视角）
    let yaw = 0, pitch = 0;
    let targetYaw = 0, targetPitch = 0;
    let cameraDist = 2.6;
    let targetCameraDist = 2.6;

    // 时间 epoch：离开再回来才会改变（整体结构慢变）
    const EPOCH_KEY = "orbit_epoch_v4";
    let epoch = parseInt(localStorage.getItem(EPOCH_KEY) || "0", 10);
    function saveEpoch() {
      localStorage.setItem(EPOCH_KEY, String(epoch));
    }

    // 全局时间：行星随停留时间慢慢运动
    const startTime = performance.now();

    // ========== 背景星空 ==========
    const STAR_COUNT = 2200;
    const stars = [];

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        const layer = Math.random() < 0.55 ? 0 : 1;
        const baseR = layer === 0 ? 0.7 : 1.2;
        const jitter = layer === 0 ? 0.5 : 0.8;
        const r = baseR + Math.random() * jitter;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        stars.push({
          x,
          y,
          z,
          layer,
          b: 0.3 + Math.random() * 0.7
        });
      }
    }
    initStars();

    // ========== 轨道系统 ==========
    const DEG = Math.PI / 180;

    const orbits = [
      { radius: 0.32, width: 0.7, color: "rgba(255,255,255,0.16)", tiltOffset: -8 * DEG, twistOffset:  10 * DEG },
      { radius: 0.50, width: 0.7, color: "rgba(255,255,255,0.13)", tiltOffset: -4 * DEG, twistOffset:  -6 * DEG },
      { radius: 0.72, width: 0.7, color: "rgba(255,255,255,0.11)", tiltOffset:  3 * DEG, twistOffset:  18 * DEG },
      { radius: 0.95, width: 0.7, color: "rgba(255,255,255,0.10)", tiltOffset: 10 * DEG, twistOffset: -15 * DEG }
    ];

    const planets = [
      { orbitIndex: 0, basePhase: 0.0, size: 0.010, color: "#f5f5ff" },
      { orbitIndex: 1, basePhase: 2.1, size: 0.012, color: "#b3d9ff" },
      { orbitIndex: 2, basePhase: 3.8, size: 0.014, color: "#ffd9a0" },
      { orbitIndex: 3, basePhase: 5.2, size: 0.016, color: "#ffe8ff" }
    ];
    // 行星角速度（弧度/秒）——慢一点，让变化更“难察觉”
    const planetSpeeds = [0.06, 0.045, 0.035, 0.028];

    // ========== 投影 ==========
    function projectPoint(px, py, pz) {
      let x = px;
      let y = py;
      let z = pz;

      const cosY = Math.cos(yaw);
      const sinY = Math.sin(yaw);
      const cosP = Math.cos(pitch);
      const sinP = Math.sin(pitch);

      // 绕 Y
      let x1 = x * cosY - z * sinY;
      let z1 = x * sinY + z * cosY;
      // 绕 X
      let y1 = y * cosP - z1 * sinP;
      z1 = y * sinP + z1 * cosP;

      const dist = cameraDist + 1.2;
      const f = 1.0 / (z1 + dist);

      const w = canvas.width;
      const h = canvas.height;
      const s = Math.min(w, h);

      return {
        sx: x1 * f * s + w / 2,
        sy: y1 * f * s + h / 2,
        depth: z1,
        scale: f
      };
    }

    // ========== epoch → 慢速结构变化 ==========
    function getTimeParams() {
      const MAX_EPOCH = 240;
      const p = (epoch % MAX_EPOCH) / MAX_EPOCH;

      const tiltAmp = 4 * DEG;
      const tiltGlobal = (p * 2 - 1) * tiltAmp;

      const ecc = 1 + 0.04 * Math.sin(p * Math.PI * 2);

      const twAmp = 5 * DEG;
      const twistGlobal = (p * 2 - 1) * twAmp;

      const phaseOffset = p * Math.PI * 2 * 0.08;

      return { tiltGlobal, ecc, twistGlobal, phaseOffset };
    }

    function orbitPoint(orbit, angle, ecc, tiltGlobal, twistGlobal) {
      const radius = orbit.radius;
      const localTilt = tiltGlobal + (orbit.tiltOffset || 0);
      const localTwist = twistGlobal + (orbit.twistOffset || 0);

      const x0 = radius * Math.cos(angle);
      const y0 = radius * ecc * Math.sin(angle);

      // 扭转 Z
      const cosTw = Math.cos(localTwist);
      const sinTw = Math.sin(localTwist);
      let x1 = x0 * cosTw - y0 * sinTw;
      let y1 = x0 * sinTw + y0 * cosTw;
      let z1 = 0;

      // 倾角 X
      const cosT = Math.cos(localTilt);
      const sinT = Math.sin(localTilt);
      let y2 = y1 * cosT - z1 * sinT;
      let z2 = y1 * sinT + z1 * cosT;

      z2 *= 1.7;

      return { x: x1, y: y2, z: z2 };
    }

    // ========== 轨迹记录：记录画面中行星的运动 ==========
    const planetTrails = planets.map(() => []); // 每颗行星一条轨迹
    let recordingTrails = false;

    function startRecordingTrails() {
      for (const t of planetTrails) t.length = 0;
      recordingTrails = true;
      clearTrailCanvas();
    }

    function stopRecordingTrails() {
      recordingTrails = false;
    }

    function clearTrailCanvas() {
      trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }

    function drawPlanetTrails() {
      clearTrailCanvas();
      const colors = [
        "rgba(245,245,255,0.9)",
        "rgba(179,217,255,0.9)",
        "rgba(255,217,160,0.9)",
        "rgba(255,232,255,0.9)"
      ];

      planetTrails.forEach((trail, idx) => {
        if (trail.length < 2) return;
        trailCtx.beginPath();
        trail.forEach((p, i) => {
          if (i === 0) {
            trailCtx.moveTo(p.x, p.y);
          } else {
            trailCtx.lineTo(p.x, p.y);
          }
        });
        trailCtx.strokeStyle = colors[idx % colors.length];
        trailCtx.lineWidth = 1.4;
        trailCtx.shadowColor = colors[idx % colors.length];
        trailCtx.shadowBlur = 8;
        trailCtx.stroke();
      });
      trailCtx.shadowBlur = 0;
    }

    // ========== 交互：旋转、缩放 ==========
    let dragging = false;
    let lastX = 0, lastY = 0;
    let hasInteracted = false;
    const hint = document.getElementById("hint");

    function userInteracted() {
      if (!hasInteracted) {
        hasInteracted = true;
        if (hint) hint.classList.add("hidden");
      }
      if (!recordingTrails) {
        startRecordingTrails();
      }
    }

    canvas.addEventListener("mousedown", (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      userInteracted();
    });

    window.addEventListener("mouseup", () => {
      dragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      const limit = Math.PI / 2 - 0.25;
      targetPitch = Math.max(-limit, Math.min(limit, targetPitch));
    });

    // 触摸旋转
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      dragging = true;
      lastX = t.clientX;
      lastY = t.clientY;
      userInteracted();
    });

    canvas.addEventListener("touchmove", (e) => {
      if (!dragging || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - lastX;
      const dy = t.clientY - lastY;
      lastX = t.clientX;
      lastY = t.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      const limit = Math.PI / 2 - 0.25;
      targetPitch = Math.max(-limit, Math.min(limit, targetPitch));
    });

    canvas.addEventListener("touchend", () => {
      dragging = false;
    });

    // 滚轮缩放
    window.addEventListener("wheel", (e) => {
      const delta = e.deltaY > 0 ? 0.18 : -0.18;
      targetCameraDist = Math.min(4.2, Math.max(1.6, targetCameraDist + delta));
      userInteracted();
    }, { passive: true });

    // 标签页切走再回来 → epoch + 1
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        epoch++;
        saveEpoch();
      }
    });

    // ========== BEFORE / NOW 截图 ==========
    let initialSnapshot = null;  // 刚进入时间后的“初始一眼”

    function captureSnapshot() {
      try {
        return canvas.toDataURL("image/png");
      } catch (e) {
        console.warn("无法截取画面", e);
        return null;
      }
    }

    const comparePanel = document.getElementById("compare-panel");
    const imgBefore = document.getElementById("img-before");
    const imgNow = document.getElementById("img-now");
    const closeCompare = document.getElementById("close-compare");
    let compareHideTimer = null;

    function openCompare(before, now) {
      imgBefore.src = before;
      imgNow.src = now;
      comparePanel.classList.add("active");
      if (compareHideTimer) clearTimeout(compareHideTimer);
      // 几秒后自动淡出，不打断用户继续玩
      compareHideTimer = setTimeout(() => {
        comparePanel.classList.remove("active");
      }, 4500);
    }

    closeCompare.addEventListener("click", () => {
      comparePanel.classList.remove("active");
      if (compareHideTimer) clearTimeout(compareHideTimer);
    });

    // ========== 主绘制循环 ==========
    function draw() {
      requestAnimationFrame(draw);

      const lerp = 0.08;
      yaw += (targetYaw - yaw) * lerp;
      pitch += (targetPitch - pitch) * lerp;
      cameraDist += (targetCameraDist - cameraDist) * lerp;

      const { tiltGlobal, ecc, twistGlobal, phaseOffset } = getTimeParams();

      const tSec = (performance.now() - startTime) / 1000; // 秒

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#02040b";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 背景星空
      for (const s of stars) {
        const p = projectPoint(s.x, s.y, s.z);
        if (p.depth > 4) continue;
        const layerFactor = s.layer === 0 ? (3.2 - cameraDist) * 0.7 : 0.5;
        const alphaBase = s.b * p.scale * 1.6;
        const alpha = Math.min(1, alphaBase * (0.6 + layerFactor));
        if (alpha <= 0.015) continue;
        ctx.fillStyle = `rgba(235,240,255,${alpha})`;
        ctx.fillRect(p.sx, p.sy, 1.0, 1.0);
      }

      // 轨道线
      for (const orbit of orbits) {
        ctx.beginPath();
        const steps = 140;
        let first = true;
        for (let i = 0; i <= steps; i++) {
          const a = (i / steps) * Math.PI * 2;
          const pos = orbitPoint(orbit, a, ecc, tiltGlobal, twistGlobal);
          const p = projectPoint(pos.x, pos.y, pos.z);
          if (p.depth > 3) continue;
          if (first) {
            ctx.moveTo(p.sx, p.sy);
            first = false;
          } else {
            ctx.lineTo(p.sx, p.sy);
          }
        }
        ctx.strokeStyle = orbit.color;
        ctx.lineWidth = orbit.width;
        ctx.stroke();
      }

      // 中央恒星
      const core = projectPoint(0, 0, 0);
      const coreRadius = 6 / cameraDist;
      const grad = ctx.createRadialGradient(
        core.sx, core.sy, 0,
        core.sx, core.sy, coreRadius * 3
      );
      grad.addColorStop(0, "rgba(255,255,255,0.7)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(core.sx, core.sy, coreRadius * 3, 0, Math.PI * 2);
      ctx.fill();

      // 行星 + 记录“在画面中的运动轨迹”
      planets.forEach((pl, index) => {
        const orbit = orbits[pl.orbitIndex];
        // 行星角度 = 初始相位 + epoch 偏移 + 停留时间运动
        const angle = pl.basePhase + phaseOffset + tSec * planetSpeeds[index];
        const pos = orbitPoint(orbit, angle, ecc, tiltGlobal, twistGlobal);
        const p = projectPoint(pos.x, pos.y, pos.z);
        if (p.depth > 3.2) return;

        // 录制轨迹：记录屏幕坐标
        if (recordingTrails) {
          const trail = planetTrails[index];
          const last = trail[trail.length - 1];
          const dx = last ? p.sx - last.x : 999;
          const dy = last ? p.sy - last.y : 999;
          const dist2 = dx * dx + dy * dy;
          if (!last || dist2 > 9) { // 相隔足够大再记，避免太密
            if (trail.length > 600) trail.shift();
            trail.push({ x: p.sx, y: p.sy });
          }
        }

        const screenSize = pl.size * canvas.height / (p.depth + cameraDist + 2.4);
        const r = Math.max(1.5, screenSize);
        ctx.beginPath();
        ctx.fillStyle = pl.color;
        ctx.shadowColor = pl.color;
        ctx.shadowBlur = 10;
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }

    // ========== 按钮 & BGM & 首屏动画 ==========
    const enterBtn = document.getElementById("enter-btn");
    const resetBtn = document.getElementById("resetView");
    const bgm = document.getElementById("bgm");

    enterBtn.addEventListener("click", () => {
      document.body.classList.add("started");
      enterBtn.classList.add("hidden");

      resetBtn.classList.remove("hidden");
      if (hint) hint.classList.remove("hidden");

      // 从初始视角开始录制行星轨迹
      startRecordingTrails();

      // 等星空真正渲染一帧后，记录 BEFORE（刚进入时的一眼）
      setTimeout(() => {
        initialSnapshot = captureSnapshot();
      }, 800);

      if (bgm) {
        bgm.volume = 0.5;
        bgm.play().catch(() => {});
      }
    });

    // 点击“回到初始视角”
    resetBtn.addEventListener("click", () => {
      // 1. 停止轨迹录制，画出这段时间行星的运动轨迹
      stopRecordingTrails();
      drawPlanetTrails();

      // 2. 只重置相机视角，不动时间/行星
      yaw = targetYaw = 0;
      pitch = targetPitch = 0;
      cameraDist = targetCameraDist = 2.6;

      // 3. 下一帧在“初始视角 + 当前行星位置”下截 NOW，并展示对比条
      requestAnimationFrame(() => {
        const nowShot = captureSnapshot();
        if (initialSnapshot && nowShot) {
          openCompare(initialSnapshot, nowShot);
        }
      });

      // 4. 等用户下一次交互时，会重新 startRecordingTrails()
    });

    requestAnimationFrame(draw);
  </script>
</body>
</html>
