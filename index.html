<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>眨眼之间 · 星空轨道</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- 进入时间 -->
  <div id="enter-btn">进入时间</div>

  <!-- 星空 + 轨道 -->
  <canvas id="space"></canvas>

  <!-- 回到初始视角 -->
  <button id="resetView" class="hidden">回到初始视角</button>

  <!-- 背景音乐：请在仓库里上传一个 bgm.mp3 到根目录 -->
  <audio id="bgm" src="bgm.mp3" loop></audio>

  <script>
    // ---------- 基础设置 ----------
    const canvas = document.getElementById("space");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    // 相机视角 & 缩放
    let yaw = 0, pitch = 0;
    let targetYaw = 0, targetPitch = 0;
    let zoom = 1, targetZoom = 1;

    // 时间（epoch）：描述“你离开/发呆了多少次”
    const EPOCH_KEY = "orbit_epoch_v1";
    let epoch = parseInt(localStorage.getItem(EPOCH_KEY) || "0", 10);
    let lastActivity = Date.now();

    function saveEpoch() {
      localStorage.setItem(EPOCH_KEY, String(epoch));
    }

    // ---------- 星星背景 ----------
    const STAR_COUNT = 2000;
    const stars = [];

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        // 随机分布在单位球壳附近
        const r = 0.6 + Math.random() * 0.6;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        stars.push({
          x, y, z,
          b: 0.2 + Math.random() * 0.8
        });
      }
    }
    initStars();

    // ---------- 轨道系统 ----------
    const orbits = [
      { radius: 0.35, width: 0.7,  color: "rgba(255,255,255,0.13)" },
      { radius: 0.52, width: 0.7,  color: "rgba(255,255,255,0.12)" },
      { radius: 0.72, width: 0.7,  color: "rgba(255,255,255,0.10)" },
      { radius: 0.95, width: 0.7,  color: "rgba(255,255,255,0.09)" },
    ];

    const planets = [
      { orbitIndex: 0, basePhase: 0.0,  size: 0.010, speed: 0.35, color: "#f5f5ff" },
      { orbitIndex: 1, basePhase: 1.9,  size: 0.012, speed: 0.26, color: "#b3d9ff" },
      { orbitIndex: 2, basePhase: 3.7,  size: 0.014, speed: 0.18, color: "#ffd9a0" },
      { orbitIndex: 3, basePhase: 5.1,  size: 0.016, speed: 0.11, color: "#ffe8ff" },
    ];

    // ---------- 工具函数 ----------
    function projectPoint(px, py, pz) {
      // yaw / pitch 旋转（摄像机）
      const cosY = Math.cos(yaw);
      const sinY = Math.sin(yaw);
      const cosP = Math.cos(pitch);
      const sinP = Math.sin(pitch);

      let x = px * cosY - pz * sinY;
      let z = px * sinY + pz * cosY;

      let y = py * cosP - z * sinP;
      z = py * sinP + z * cosP;

      const baseDist = 2.2;
      const f = (0.85 * zoom) / (z + baseDist);

      const w = canvas.width;
      const h = canvas.height;
      const s = Math.min(w, h);

      return {
        sx: x * f * s + w / 2,
        sy: y * f * s + h / 2,
        depth: z,
        scale: f
      };
    }

    // ---------- 时间驱动的参数 ----------
    function getTimeParams(time) {
      const MAX_EPOCH = 60;
      const progress = (epoch % MAX_EPOCH) / MAX_EPOCH; // 0~1 循环

      // 轨道平面的倾角（岁差） -15° ~ +15°
      const tiltRange = (15 * Math.PI) / 180;
      const tilt = (progress * 2 - 1) * tiltRange;

      // 轨道的椭圆化程度（ecc = 1 ~ 1.3）
      const ecc = 1 + 0.3 * Math.sin(progress * Math.PI * 2);

      // 轨道整体的扭转角（绕中心旋转）0 ~ 30°
      const twistRange = (30 * Math.PI) / 180;
      const twist = progress * twistRange;

      // 行星整体相位偏移
      const phaseOffset = progress * Math.PI * 2 * 0.4;

      // 行星在当前帧自身的运动（让它们流动起来，不太死）
      const t = time * 0.00004; // 控制转动速度

      return { tilt, ecc, twist, phaseOffset, t };
    }

    // ---------- 鼠标 / 触摸交互 ----------
    let dragging = false;
    let lastX = 0, lastY = 0;

    function markActivity() {
      lastActivity = Date.now();
    }

    canvas.addEventListener("mousedown", (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      markActivity();
    });

    window.addEventListener("mouseup", () => {
      dragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      targetPitch = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, targetPitch));
      markActivity();
    });

    // 触控
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      dragging = true;
      lastX = t.clientX;
      lastY = t.clientY;
      markActivity();
    });

    canvas.addEventListener("touchmove", (e) => {
      if (!dragging || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - lastX;
      const dy = t.clientY - lastY;
      lastX = t.clientX;
      lastY = t.clientY;
      targetYaw += dx * 0.0022;
      targetPitch += dy * 0.002;
      targetPitch = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, targetPitch));
      markActivity();
    });

    canvas.addEventListener("touchend", () => {
      dragging = false;
    });

    // 滚轮缩放
    window.addEventListener("wheel", (e) => {
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      targetZoom = Math.min(1.9, Math.max(0.8, targetZoom + delta));
      markActivity();
    }, { passive: true });

    // 长时间停留无操作 → epoch + 1
    setInterval(() => {
      const now = Date.now();
      if (now - lastActivity > 15000) {
        epoch++;
        saveEpoch();
        lastActivity = now;
      }
    }, 5000);

    // 标签页切走再回来 → epoch + 1
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        epoch++;
        saveEpoch();
      }
    });

    // ---------- 主绘制 ----------
    function draw(time) {
      requestAnimationFrame(draw);

      // 平滑相机
      const lerp = 0.08;
      yaw += (targetYaw - yaw) * lerp;
      pitch += (targetPitch - pitch) * lerp;
      zoom += (targetZoom - zoom) * lerp;

      const { tilt, ecc, twist, phaseOffset, t } = getTimeParams(time);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#02040b";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ---- 画背景星星 ----
      for (const s of stars) {
        const p = projectPoint(s.x, s.y, s.z);
        if (p.depth > 2) continue;
        const flicker = 0.8 + Math.random() * 0.4;
        const alpha = Math.min(1, s.b * p.scale * 1.6 * flicker);
        if (alpha <= 0.01) continue;
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(p.sx, p.sy, 1.0, 1.0);
      }

      // ---- 轨道坐标辅助函数 ----
      function orbitPoint(radius, angle) {
        // angle: 在轨道平面内的位置
        const x0 = radius * Math.cos(angle);
        const y0 = radius * ecc * Math.sin(angle); // 椭圆化

        // 先绕 Z 轴 twist，再绕 X 轴 tilt
        const cosTw = Math.cos(twist);
        const sinTw = Math.sin(twist);
        let x1 = x0 * cosTw - y0 * sinTw;
        let y1 = x0 * sinTw + y0 * cosTw;
        let z1 = 0;

        const cosT = Math.cos(tilt);
        const sinT = Math.sin(tilt);
        let y2 = y1 * cosT - z1 * sinT;
        let z2 = y1 * sinT + z1 * cosT;

        return { x: x1, y: y2, z: z2 };
      }

      // ---- 画轨道线 ----
      for (const orbit of orbits) {
        ctx.beginPath();
        const steps = 130;
        let first = true;
        for (let i = 0; i <= steps; i++) {
          const a = (i / steps) * Math.PI * 2;
          const pos = orbitPoint(orbit.radius, a);
          const p = projectPoint(pos.x, pos.y, pos.z);
          if (p.depth > 2) continue;
          if (first) {
            ctx.moveTo(p.sx, p.sy);
            first = false;
          } else {
            ctx.lineTo(p.sx, p.sy);
          }
        }
        ctx.strokeStyle = orbit.color;
        ctx.lineWidth = orbit.width;
        ctx.stroke();
      }

      // ---- 中央恒星（不太亮）----
      const starCore = projectPoint(0, 0, 0);
      const coreRadius = 6 * zoom;
      const grad = ctx.createRadialGradient(
        starCore.sx, starCore.sy, 0,
        starCore.sx, starCore.sy, coreRadius * 2
      );
      grad.addColorStop(0, "rgba(255,255,255,0.65)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(starCore.sx, starCore.sy, coreRadius * 2, 0, Math.PI * 2);
      ctx.fill();

      // ---- 画行星 ----
      for (const pl of planets) {
        const orbit = orbits[pl.orbitIndex];
        const base = pl.basePhase;
        const angle = base + phaseOffset + t * pl.speed * Math.PI * 2;
        const pos = orbitPoint(orbit.radius, angle);
        const p = projectPoint(pos.x, pos.y, pos.z);
        if (p.depth > 2) continue;

        const screenSize = pl.size * canvas.height * zoom / (p.depth + 2.3);
        const r = Math.max(1.5, screenSize);

        ctx.beginPath();
        ctx.fillStyle = pl.color;
        ctx.shadowColor = pl.color;
        ctx.shadowBlur = 8;
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // ---------- 按钮交互 ----------
    const enterBtn = document.getElementById("enter-btn");
    const resetBtn = document.getElementById("resetView");
    const bgm = document.getElementById("bgm");

    enterBtn.addEventListener("click", () => {
      enterBtn.classList.add("hidden");
      resetBtn.classList.remove("hidden");

      // 自动播放 BGM（有的浏览器需要用户交互后才允许播放）
      if (bgm) {
        bgm.volume = 0.5;
        bgm.play().catch(() => {});
      }
      markActivity();
    });

    resetBtn.addEventListener("click", () => {
      targetYaw = 0;
      targetPitch = 0;
      targetZoom = 1;
      markActivity();
    });

    // 初始让画布可交互但被按钮盖着
    markActivity();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
